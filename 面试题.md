# 面试题

## new 实现了什么

1. 创建一个对象
2. 将对象的 `_proto_` 指向构造函数的 prototype
3. 将这个对象作为构造函数的this
4. 返回该对象

## react vue diff算法

1. 响应式数据更新后，会触发Watcher的回调函数去更新视图。render函数生成的就是vnode，update函数就是带着vnode跑一次patch
2. 如果不是相同节点，直接销毁旧vnode，添加新vnode
3. 如果是相同节点，尽量复用
4. 如果新vnode是文字vnode，直接替换内容
5. 如果不是，要对子节点进行比较
6. 有新节点就新增，有旧节点就删除，如果都有，就是diff算法的过程了
7. 新旧节点的首尾都会有一个指针进行比较，并向内部收缩，直到没有节点可以进行比较
8. 比较时，会有一个sameVnode函数，通过key来进行比较，看节点是否可用
9. 如果有一项命中，就递归的进入patchVnode针对单个vnode的过程，直到新旧节点有一端相遇（说明都被patch过了）
10. 如果oldStartIndex > oldEndIndex，说明旧节点被patch完了，需要新增
11. 如果newStartIndex > newEndIndex，说明新节点被patch完了，需要删除

## 线上跨域

1.jsonp
2.CORS
3.proxy+nginx代理

## flex:1

1. flex:1 === flex:1(flex-grow) 1(flex-shrink) 0(flex-basis)
2. flex-grow：放大比例，默认为0，即有空间也不会放大
3. flex-shrink：缩小比例，默认为1，即空间不足会缩小
4. flex-basis：分配多余空间之前，会占据的主轴空间，默认auto，即本身的大小

## vuex原理

1. vuex利用vue的mixin混入机制，在beforeCreate前往store注入组件实例，并注册store的引用属性$store
2. vuex的state是响应式的，是借助了vue的data是响应式，getter则是借助了vue的computed实现数据监听

## vue-router原理

## https和http区别

1. http是明文，https有ssl加密
2. https需要证书
3. 端口不通
4. 链接方式不同，http是无状态的

## 伪类伪元素区别

1. 伪类是`:`，伪元素是`::`
2. 是否需要添加新元素才能达成目的，是的话就是伪元素，不是的话就是伪类

## computed和watch区别

1. computed通常是多个数据影响一个数据，不支持异步，并且有缓存，依赖值不变会直接使用缓存
2. watch通常是一个数据影响多个数据，支持异步

## vue3 teleport

1. 瞬移组件，to属性后面是要瞬移的标签
2. disabled，禁用瞬移功能
3. 不论是否瞬移，都可以取到teleport的子组件中的数据
4. 根据teleport的顺序进行挂载
5. 原理就是将teleport中的children挂载到to的DOM中

## map和set区别

1. map类似于object，是key:value，set类似于array，是value:value
2. map的key不能改变，value可以改变，set的value不能改变（因为value就是key）

## get和post的区别 

1. get只读，post可以修改
2. get的参数放在url中，post的放在请求体中
3. post回退时会重新请求
4. 浏览器会主动缓存get请求地址
5. get的请求参数会被保留在浏览器历史记录中
6. get的参数有长度限制

## http1和http2的区别

1. http2是二进制传输
2. 头部压缩
3. 多路复用
4. 服务器推送
5. 提高安全性(https基于http2)
6. 防止队头阻塞

## webpack打包策略：
搜索时间-缩小文件搜索范围，减少不必要的编译工作
解析时间
压缩时间
二次打包时间

开启thread-loader
防止 webpack启动慢  预热
合理使用缓存 cache-loader（保存和读取缓存文件是存在时间开销的，因此只针对相对来说大的loader） HardSourceWebpackPlugin
优化压缩时间

优化loader配置通过test,include,exclude来命中需要应用规则的文件
优化 resolve.module 配置webpack寻找第三方模块地址
优化 resolve.alias 配置别名把原本路径映射成一个新的路径，减少耗时的递归解析

## webpack原理

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

## 从输入一个 URL 地址到浏览器完成渲染的整个过程

1. 浏览器地址栏输入 URL 并回车
2. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
3. DNS 解析 URL 对应的 IP
4. 根据 IP 建立 TCP 连接（三次握手）
5. 发送 http 请求
6. 服务器处理请求，浏览器接受 HTTP 响应
7. 浏览器解析并渲染页面
8. 关闭 TCP 连接（四次握手）

## webpack Plugin 和 Loader 的区别

Loader：
用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 build 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等。

Plugin
目的在于解决 loader 无法实现的其他事,它直接作用于 webpack，扩展了它的功能。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

## apply call bind 区别

- 三者都可以改变函数的 this 对象指向。
- 三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。
- 三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。
- bind 是返回绑定 this 之后的函数，便于稍后调用；apply 、call 则是立即执行 。
- bind()会返回一个新的函数，如果这个返回的新的函数作为构造函数创建一个新的对象，那么此时 this 不再指向传入给 bind 的第一个参数，而是指向用 new 创建的实例
