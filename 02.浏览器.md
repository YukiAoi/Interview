## 浏览器

### 从输入URL到页面加载的全过程

1. 浏览器地址栏输入 URL 并回车
1. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
1. DNS 解析 URL 对应的 IP
1. 根据 IP 建立 TCP 连接（三次握手）
1. 发送 http 请求
1. 服务器处理请求，浏览器接受 HTTP 响应
1. 浏览器解析并渲染页面
1. 关闭 TCP 连接（四次握手）

### 在浏览器中输入URL到显示页面经历过程中，涉及到哪些协议？

1. DNS协议（解析域名）
1. UDP协议（DNS服务器是基于UDP）
1. HTTP协议（建立HTTP链接）
1. TCP协议（报文传给TCP层）
1. HTTPS协议（对HTTP数据进行加密）
1. IP协议（数据包发送给IP层）
1. 其他物理层协议（网段寻址）

其中：

1. `DNS协议，http协议，https协议属于应用层`
1. `TCP/UDP属于传输层`
1. `IP协议，ARP协议属于网络层`

### 浏览器的主要功能

浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。

### 浏览器如何渲染UI

1. 请求文档的内容
1. 解析HTML文档，并创建`DOM树`和`渲染树`
1. `DOM树`和`渲染树`合并后开始`布局`，为每个节点分配一个应出现在屏幕上的确切坐标
1. 绘制，渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来

### 浏览器的主要组成部分是什么？

1. `用户界面`，包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
2. `浏览器引擎`，在用户界面和呈现引擎之间传送指令。
3. `呈现引擎`，负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
4. `网络`，用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
5. `用户界面后端`，用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
6. `JavaScript解释器`，用于解析和执行 JavaScript 代码。
7. `数据存储`，这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。

### DOM Tree是如何构建的

1.  转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串
1.  生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens
1.  构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope
1.  生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree

### 浏览器重绘与重排的区别

#### 重排/回流（Reflow）

当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素

#### 重绘(Repaint)

当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变

单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分

重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。

`重绘`不一定会出现`重排`，`重排`必然会出现`重绘`。


#### 如何触发重排和重绘

任何改变用来构建渲染树的信息都会导致一次重排或重绘：

1. 添加、删除、更新DOM节点
1. 通过display: none隐藏一个DOM节点-触发重排和重绘
1. 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
1. 移动或者给页面中的DOM节点添加动画
1. 添加一个样式表，调整样式属性
1. 用户行为，例如调整窗口大小，改变字号，或者滚动。

#### 如何避免重绘或者重排？

1. `集中改变样式`，不要一条一条地修改 DOM 的样式。
1. 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
1. 为动画的 HTML 元件使用 `fixed` 或 `absoult` 的 `position`，那么修改他们的 CSS 是不会重排的。
1. 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
1. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
1. 动画开始`GPU`加速，`translate`使用`3D`变化
1. 提升为合成层
```css
#target {
  will-change: transform;
}
```

### 进程、线程和协程

#### 进程

是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，`是操作系统进行资源分配和调度的一个独立单位`，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

#### 线程

是程序执行中一个单一的顺序控制流程，是`程序执行流的最小单元`，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

#### 协程

是一种`基于线程之上，但又比线程更加轻量级的存在`，这种由程序员自己写程序来管理的轻量级线程叫做`用户空间线程`，具有对内核来说不可见的特性。

#### 进程和线程的区别

1. 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
1. 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
1. 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源
1. 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些

#### 进程和线程的联系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程
1. 资源分配给进程，同一进程的所有线程共享该进程的所有资源
1. 处理机分给线程，即真正在处理机上运行的是线程
1. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步

### 进程间的通信方式

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

1. `匿名管道( pipe )`：管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程关系**。
1. `高级管道(popen)`：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
1. `有名管道 (named pipe) `：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
1. `消息队列( message queue )`：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
1. `信号量( semophore )`：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
1. `信号 ( singal )`：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
1. `共享内存( shared memory )`：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
1. `套接字( socket ) 通信`： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信


### 浏览器样式兼容

#### CSS初始化

每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化（覆盖默认样式）

1. `*{ margin: 0; padding: 0;}`
1. 库：normalize.css

#### 浏览器私有属性

常用的前缀有：
1. firefox浏览器 ：-moz-
1. chrome、safari ：-webkit-
1. opera ：-o- / -xv-
1. IE浏览器 ：-ms-（目前只有 IE 8+支持）

#### CSS hack（条件hack、属性级hack、选择符级hack）

### JS垃圾回收

项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。

#### 机制

浏览器的`Javascript`具有自动垃圾回收机制(`GC:Garbage Collecation`)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。

1. 标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。
1. 查找引用（谷歌）：浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。
1. 引用计数法（IE）：当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。

#### 优化手段

1. 内存优化
1. 手动释放：取消内存的占用即可
- 堆内存：fn = null 【null：空指针对象】
- 栈内存：把上下文中，被外部占用的堆的占用取消即可。

#### 内存泄漏

常见的内存泄露主要有4中：
1. 全局变量
1. 闭包
1. DOM 元素的引用
1. 定时器